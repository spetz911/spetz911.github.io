--- layout: post title: spin\_lock date: 2012-06-07 comments: false ---

{{ page.title }}
================

\
Alex Krizhanovsky: Ребят, такой код\
\
spin\_lock(&keepalive\_lock);\
.....\
ret = kmem\_cache\_alloc(session\_cache, GFP\_ATOMIC|\_\_GFP\_ZERO);\
....\
      if (!login) {\
                          kmem\_cache\_free(session\_cache, ret);\
        ...........\
      }\
......\
spin\_unlock(&keepalive\_lock);\
\
(Олег, spin\_lock - это быстрая блокировка, аналог pthread\_spin\_lock
(который, кстати в user space использовать не следует),
kmem\_cache\_alloc/kmem\_cache\_free - аллокации/деаллокации памяти)\
\
--- очень плох с точки зрения lock contention.\
\
Аллокации памяти могут выполнять довольно сложные операции, хоть и не
всегда. Поэтому:\
1. аллоцируем ДО лока, проверяем условия под локом и если они не
выполняются (если это редкий случай) - отпускаем лок и освобождаем
память\
2. деаллоцируем память ПОСЛЕ отпускания лока (Юр, это я про
hps\_session\_insert\_ipv6)\
\
Общая идея (на многопроцессорных системах) - лучне лишний раз сделать
alloc/free без лока, чем меньше аллокаций, но под локом. Пока вы на 2-4
ядрах - может быть лучше все далать пол локом, если вы на 8-16-32 ядрах
и выше - объем кода под локом - одно из самых критичных мест\

Comments
--------
