<p>&#8212; layout: post title: spin_lock date: 2012-06-07 comments: false &#8212;</p>

<h1>Spin Lock</h1>

<p>\
Alex Krizhanovsky: Ребят, такой код\
\
spin_lock(&amp;keepalive_lock);\
&#8230;..\
ret = kmem_cache_alloc(session_cache, GFP_ATOMIC|__GFP_ZERO);\
&#8230;.\
      if (!login) {\
                          kmem_cache_free(session_cache, ret);\
        &#8230;&#8230;&#8230;..\
      }\
&#8230;&#8230;\
spin_unlock(&amp;keepalive_lock);\
\
(Олег, spin_lock - это быстрая блокировка, аналог pthread_spin_lock
(который, кстати в user space использовать не следует),
kmem_cache_alloc/kmem_cache_free - аллокации/деаллокации памяти)\
\
&#8212; очень плох с точки зрения lock contention.\
\
Аллокации памяти могут выполнять довольно сложные операции, хоть и не
всегда. Поэтому:\
1. аллоцируем ДО лока, проверяем условия под локом и если они не
выполняются (если это редкий случай) - отпускаем лок и освобождаем
память\
2. деаллоцируем память ПОСЛЕ отпускания лока (Юр, это я про
hps_session_insert_ipv6)\
\
Общая идея (на многопроцессорных системах) - лучне лишний раз сделать
alloc/free без лока, чем меньше аллокаций, но под локом. Пока вы на 2-4
ядрах - может быть лучше все далать пол локом, если вы на 8-16-32 ядрах
и выше - объем кода под локом - одно из самых критичных мест\</p>

<h2>Comments</h2>
